---
title: 《计算几何——算法与应用（第三版）》学习笔记
date: 2023-09-05 15:58:17
updated: 2023-09-05 15:58:17
cover: cover.webp
katex: true
tags:
    - 计算几何
categories:
    - 学习笔记
---

## 计算几何：导言

Voronoi 图（Voronoi diagram），可以为覆盖多个城市的商业区域建立模型，指挥机器人，甚至描述和模拟晶体的生长过程。

### 凸包的例子

![](hull.webp)

平面的一个子集$S$被称为是“凸”的，当且仅当对于任意两点$p, q ∈ S$，线段$\bar{pq}$都完全属于$S$。
集合$S$的凸包$CH(S)$，就是包含$S$的最小凸集——更准确地说，它是所有包含$S$的所有凸集的交集。
可以将平面有限点集$P$的凸包定义为：顶点取自于$P$且包含$P$中所有点的那个唯一的凸多边形（convex polygon）。

所以计算出一个点集的凸包可以取所有点对，如果其他所有点都在这两个点组成的直线一侧（如右侧），则说明这两个点在凸包上。这种方法的时间复杂度是$O(n^3)$

有一些特殊情况：
- 点有可能在线上，这就是所谓的“退化情况”（degenerate case）。
- 浮点运算（floating point arithmetric）带来的舍入误差（rounding error）可能导致找出多余的边，或少找一些边。

有一个更好的递增式算法（incremental algorithm）：
- 对点集按照$x$轴排序。
- 按照顺序每次将一个点加入集合中。
- 若集合中最后三个点构成一个左拐（left-turn），则删除最后三个点中居中的点；如果集合中的点数大于三，就再做检查，直到集合中最后三个点构成的是右拐（right-turn）。
- 上面是上凸包（upper hull）的构造过程，下凸包（lower hull）的构造思路是相似的。

有两种特殊情况：
- 存在$x$坐标相同的点，那么排序时需在$x$坐标相同时比较$y$坐标。
- 判断左拐还是右拐时，有可能三个点共线，这时也需要删除居中的点。

> 【定理 1.1】
> 给定包含$n$个点的任意一个平面点集，其凸包都可以在$O(nlogn)$时间内构造出来。

### 退化及鲁棒性

先考虑一般情况，做一些假设，忽略特殊情况。之后再将特殊情况集成进算法中。
实现过程中会出现鲁棒性（robustness）的问题，一种方法是借助于某个支持精确运算（exact arithmetic）的软件包，另一种方法是调整算法，使之能够检测到可能出现的不一致问题，并采取适当的措施以避免程序崩溃。

### 应用领域

- 计算机图形学
- 机器人学
- 地理信息系统（GIS）
- CAD/CAM
- 其他应用领域
  - 分子建模
  - 模式识别（pattern recognition）

## 线段求交：专题图叠合

为了增加地图的可读性，地理信息系统将（不同类型的）信息划分为若干层（layer）。每一层都是一副专题图（thematic map）。

### 线段求交

线段求交问题（line segment intersection problem）

定义交点需要确定线段是否为闭的，如果是闭的，那么一条线段的端点落在另一条线段上，则相交。

如果依次检查每一对线段，看它们是否相交，这种算法需要$O(n^2)$的时间。但大多数情况下焦点数会远小于平方量级。所以需要一种运行时间不仅取决于输入中线段的数目，还取决于（实际的）交点数目。这样的算法被称为“输出敏感的”算法（output-sensitive algorithm）。在这个问题上可以称为“交点敏感的”（intersection-sensitive）。

引入平面扫描线算法（plane sweep algorithm）。
- 扫描线（sweep line）：虚拟的线，通过移动扫描线会与几何做交互。
- 状态（status）：随着扫描线的推进，扫描线会遇到某些事件点，此时扫描线的状态需要更新。
- 事件点（event point）：就本算法而言，是各线段的端点。
- 状态结构（status structure）：保存了某个时刻与扫描线相交的线段。例如扫描线遇到的事件点是线段的上端点，则需要将线段插入到状态结构中，若是下端点则需删去。

当引入一条线段到状态结构中时，需要将其与自身的上端点左、右紧邻的线段进行交点测试。此后，当扫描线推进到某个新的位置时，与某条线段紧邻的邻居有可能发生变化，此时，需要将它与新的邻居进行测试。所以状态结构不仅要在端点处进行更新，也需要在交点处更新。

> 引理 2.1
> 设两条非水平的线段$s_i$和$s_j$只相交于其内部的一点$p$，而且，任何第三条线段都不经过$p$。则在（扫描线到达）高于$p$的某个事件点处（时），$s_i$和$s_j$必然会彼此紧邻，并因此接受相交测试（于是对应的交点将被发现）。

> 定理 2.4
> 给定由平面上任意$n$条线段构成的一个集合$S$。可以在$O(nlogn+Ilogn)$时间内，使用$O(n)$空间，报告出$S$中各线段之间的所有交点，以及与每个交点相关的所有线段。其中，$I$为实际的交点总数。

### 双向链接边表

（doubly-connected edge list）

一种用来表示由图的平面嵌入（planar embeddings of graph）而导出的平面子区域划分问题的数据结构。只要原来的图是连通的，其对应的子区域划分就必然也是连通的。原图中每个节点（node）的嵌入，称为一个顶点（vertex）；原图中每条弧（arc）的嵌入，称为一条边（edge）。子区域划分的“面”（face）指的是在平面上除去所有的顶点和所有的边之后，余下的每一个极大的连通子集。

本章中讨论的边是开的，面也是开的（其边界由子区域划分的某些边和点围成）。所谓一个子区域划分的复杂度，就是构成该子区域划分的顶点、边和面的总数。

若一个顶点是某条边的端点，就说这个顶点与这条边是关联的（incident）。一张面与其边界上的每条边、每个顶点也是关联的。

这个数据结构要能完成以下操作：
- 围绕指定的某张面，沿其边界遍历（traverse）一周；
- 在指定一条公共边之后，通过与其相邻于一侧的面，找到另一侧的那张面；
- 在给定一个顶点之后，（依次）枚举出与之关联的所有边。

双向链接边表中会存储附加信息或者说属性信息（attribute information），用来扩展图的含义。这种数据结构中，一条边被当作两条边用，像劈竹子一样劈开，得到的叫做半边（half edge），两条半边方向相反，互为孪生兄弟（twin），但其左侧都是与它所关联的面。半边的起点（origin）与终点（destination）互相颠倒重合。

双向链接边表由三组记录构成：一组对应于顶点，一组对应于面，还有一组对应于边。举例以及三张表的结构如下：

<image src="doubly-connected_edge_list.webp" height="250px" />

| Vertex | Coordinates |  IncidentEdge   |
| :----: | :---------: | :-------------: |
| $v_1$  |   $(0,4)$   | $\vec{e}_{1,1}$ |
| $v_2$  |   $(2,4)$   | $\vec{e}_{4,2}$ |
| $v_3$  |   $(2,2)$   | $\vec{e}_{2,1}$ |
| $v_4$  |   $(1,1)$   | $\vec{e}_{2,2}$ |

| Face  | OuterComponent  | InnerComponents |
| :---: | :-------------: | :-------------: |
| $f_1$ |      $nil$      | $\vec{e}_{1,1}$ |
| $f_2$ | $\vec{e}_{4,1}$ |      $nil$      |

|    Half-edge    | Origin |      Twin       | IncidentFace |      Next       |      Prev       |
| :-------------: | :----: | :-------------: | :----------: | :-------------: | :-------------: |
| $\vec{e}_{1,1}$ | $v_1$  | $\vec{e}_{1,2}$ |    $f_1$     | $\vec{e}_{4,2}$ | $\vec{e}_{3,1}$ |
| $\vec{e}_{1,2}$ | $v_2$  | $\vec{e}_{1,1}$ |    $f_2$     | $\vec{e}_{3,2}$ | $\vec{e}_{4,1}$ |
| $\vec{e}_{2,1}$ | $v_3$  | $\vec{e}_{2,2}$ |    $f_1$     | $\vec{e}_{2,2}$ | $\vec{e}_{4,2}$ |
| $\vec{e}_{2,2}$ | $v_4$  | $\vec{e}_{2,1}$ |    $f_1$     | $\vec{e}_{3,1}$ | $\vec{e}_{2,1}$ |
| $\vec{e}_{3,1}$ | $v_3$  | $\vec{e}_{3,2}$ |    $f_1$     | $\vec{e}_{1,1}$ | $\vec{e}_{2,2}$ |
| $\vec{e}_{3,2}$ | $v_1$  | $\vec{e}_{3,1}$ |    $f_2$     | $\vec{e}_{4,1}$ | $\vec{e}_{1,2}$ |
| $\vec{e}_{4,1}$ | $v_3$  | $\vec{e}_{4,2}$ |    $f_2$     | $\vec{e}_{1,2}$ | $\vec{e}_{3,2}$ |
| $\vec{e}_{4,2}$ | $v_2$  | $\vec{e}_{4,1}$ |    $f_1$     | $\vec{e}_{2,1}$ | $\vec{e}_{1,1}$ |

在实际的问题中，需要定制化地增删记录内容。有些实现中，可能会要求子区域划分的顶点和边所对应的图必须是连通的，为此，需要引入一些虚边（dummy edge）。

### 计算子区域划分的叠合

给定两个子区域划分$S_1$和$S_2$，其叠合记作$O(S_1, S_2)$。

叠合算法首先将$S_1$和$S_2$所对应的两个双向链接边表复制到一个新的双向链接边表中，通过计算两个边网络之间的交点，并适当地将两个双向链接边表中的相关部分链接起来，最终把这个新的双向链接边表转化为对应于$O(S_1, S_2)$的一个合法的双向链接边表。
使用扫描线算法，在遇到一个事件点时，如果涉及到的边分别来自不同的子区域划分，则对新的双向链接边表做局部调整，保证扫描线扫过的区域已经被调整好。由于调整操作的复杂度不会超过线段求交算法的复杂度，所以可以在$O(nlogn + klogn)$时间内计算出$O(S_1, S_2)$所对应双向链接边表中所有顶点记录和半边记录，其中$n$为$S_1$和$S_2$的总体复杂度，而$k$为二者叠合结果的复杂度。
对于面，需要更复杂的操作。大致思路是构造一个图$G$，图的每一个节点对应一个环。利用这个图的节点，可以为每一连通子块生成一张面。而标记这张面属于原先的哪个子区域划分，则是看其顶点位于原子区域划分的哪个面内。

判断一个环是面的边界还是空洞的边界的方法是：找到环中最左端的顶点$v$（若有多个则选最低者），看与之相关联的两条边朝这张面内部所张的角度，小于$180°$则是外边界；否则就是空洞的边界。

{% note warning flat %}
TODO: 面的设置
{% endnote %}

> 定理 2.6
> 给定任意两个平面子区域划分$S_1$和$S_2$，其复杂度分别为$n_1$和$n_2$，令$n = n_1 + n_2$。则可以在$O(nlogn + klogn)$时间内计算出$S_1$和$S_2$的叠合，其中$k$为叠合结果的复杂度。

### 布尔运算

<image src="boolean_operation.webp" height="300px" />

地图叠合算法是一个强有力的工具，在众多不同的应用中它都可以大显身手。其中特别有用的一点，就是可以用以实现两个多边形$P_1$和$P_2$的布尔运算（boolean operation）——并（union）、交（intersection）和差（difference）。

> 推论 2.7
> 任意给定两个多边形$P_1$和$P_2$，设其顶点数分别为$n_1$、$n_2$，令$n := n_1 + n_2$。则可以在$O(nlogn + klogn)$时间内，计算出$P_1 ∩ P_2$、$P_1 ∪ P_2$或$P_1 \backslash P_2$，其中$k$为最终输出的复杂度。

## 多边形三角剖分：画廊看守

艺术画廊问题（art gallery problem）

### 看守与三角形剖分

对于多边形内部的任何一个点，只要联接于它与某台摄像机之间的开线段完全落在多边形的内部，它就能被这台摄像机监视到。“计算出特定多边形所需摄像机的最小数目”这一问题，是 NP-hard 问题。

通过极大的一组互不相交的对角线（diagonal），可将一个多边形分解为多个三角形——称作该多边形的三角剖分（trangulation）。
三角形剖分的例子：{% inlineImg trangulation.webp 100px %}

> 定理 3.1
> 任何简单多边形都存在（至少）一个三角形剖分；若其顶点数目为$n$，则它的每个三角形剖分都恰好包含$n - 2$个三角形。


