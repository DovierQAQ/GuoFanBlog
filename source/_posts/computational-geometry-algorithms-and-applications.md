---
title: 《计算几何——算法与应用（第三版）》学习笔记
date: 2023-09-05 15:58:17
updated: 2023-09-05 15:58:17
cover: cover.webp
katex: true
tags:
    - 计算几何
categories:
    - 学习笔记
---

## 计算几何：导言

Voronoi 图（Voronoi diagram），可以为覆盖多个城市的商业区域建立模型，指挥机器人，甚至描述和模拟晶体的生长过程。

### 凸包的例子

![](hull.webp)

平面的一个子集$S$被称为是“凸”的，当且仅当对于任意两点$p, q ∈ S$，线段$\overline{pq}$都完全属于$S$。
集合$S$的凸包$CH(S)$，就是包含$S$的最小凸集——更准确地说，它是所有包含$S$的所有凸集的交集。
可以将平面有限点集$P$的凸包定义为：顶点取自于$P$且包含$P$中所有点的那个唯一的凸多边形（convex polygon）。

所以计算出一个点集的凸包可以取所有点对，如果其他所有点都在这两个点组成的直线一侧（如右侧），则说明这两个点在凸包上。这种方法的时间复杂度是$O(n^3)$

有一些特殊情况：
- 点有可能在线上，这就是所谓的“退化情况”（degenerate case）。
- 浮点运算（floating point arithmetric）带来的舍入误差（rounding error）可能导致找出多余的边，或少找一些边。

有一个更好的递增式算法（incremental algorithm）：
- 对点集按照$x$轴排序。
- 按照顺序每次将一个点加入集合中。
- 若集合中最后三个点构成一个左拐（left-turn），则删除最后三个点中居中的点；如果集合中的点数大于三，就再做检查，直到集合中最后三个点构成的是右拐（right-turn）。
- 上面是上凸包（upper hull）的构造过程，下凸包（lower hull）的构造思路是相似的。

有两种特殊情况：
- 存在$x$坐标相同的点，那么排序时需在$x$坐标相同时比较$y$坐标。
- 判断左拐还是右拐时，有可能三个点共线，这时也需要删除居中的点。

> 【定理 1.1】
> 给定包含$n$个点的任意一个平面点集，其凸包都可以在$O(nlogn)$时间内构造出来。

### 退化及鲁棒性

先考虑一般情况，做一些假设，忽略特殊情况。之后再将特殊情况集成进算法中。
实现过程中会出现鲁棒性（robustness）的问题，一种方法是借助于某个支持精确运算（exact arithmetic）的软件包，另一种方法是调整算法，使之能够检测到可能出现的不一致问题，并采取适当的措施以避免程序崩溃。

### 应用领域

- 计算机图形学
- 机器人学
- 地理信息系统（GIS）
- CAD/CAM
- 其他应用领域
  - 分子建模
  - 模式识别（pattern recognition）

## 线段求交：专题图叠合

为了增加地图的可读性，地理信息系统将（不同类型的）信息划分为若干层（layer）。每一层都是一副专题图（thematic map）。

### 线段求交

线段求交问题（line segment intersection problem）

定义交点需要确定线段是否为闭的，如果是闭的，那么一条线段的端点落在另一条线段上，则相交。

如果依次检查每一对线段，看它们是否相交，这种算法需要$O(n^2)$的时间。但大多数情况下焦点数会远小于平方量级。所以需要一种运行时间不仅取决于输入中线段的数目，还取决于（实际的）交点数目。这样的算法被称为“输出敏感的”算法（output-sensitive algorithm）。在这个问题上可以称为“交点敏感的”（intersection-sensitive）。

引入平面扫描线算法（plane sweep algorithm）。
- 扫描线（sweep line）：虚拟的线，通过移动扫描线会与几何做交互。
- 状态（status）：随着扫描线的推进，扫描线会遇到某些事件点，此时扫描线的状态需要更新。
- 事件点（event point）：就本算法而言，是各线段的端点。
- 状态结构（status structure）：保存了某个时刻与扫描线相交的线段。例如扫描线遇到的事件点是线段的上端点，则需要将线段插入到状态结构中，若是下端点则需删去。

当引入一条线段到状态结构中时，需要将其与自身的上端点左、右紧邻的线段进行交点测试。此后，当扫描线推进到某个新的位置时，与某条线段紧邻的邻居有可能发生变化，此时，需要将它与新的邻居进行测试。所以状态结构不仅要在端点处进行更新，也需要在交点处更新。

> 引理 2.1
> 设两条非水平的线段$s_i$和$s_j$只相交于其内部的一点$p$，而且，任何第三条线段都不经过$p$。则在（扫描线到达）高于$p$的某个事件点处（时），$s_i$和$s_j$必然会彼此紧邻，并因此接受相交测试（于是对应的交点将被发现）。

> 定理 2.4
> 给定由平面上任意$n$条线段构成的一个集合$S$。可以在$O(nlogn+Ilogn)$时间内，使用$O(n)$空间，报告出$S$中各线段之间的所有交点，以及与每个交点相关的所有线段。其中，$I$为实际的交点总数。

### 双向链接边表

（doubly-connected edge list）

一种用来表示由图的平面嵌入（planar embeddings of graph）而导出的平面子区域划分问题的数据结构。只要原来的图是连通的，其对应的子区域划分就必然也是连通的。原图中每个节点（node）的嵌入，称为一个顶点（vertex）；原图中每条弧（arc）的嵌入，称为一条边（edge）。子区域划分的“面”（face）指的是在平面上除去所有的顶点和所有的边之后，余下的每一个极大的连通子集。

本章中讨论的边是开的，面也是开的（其边界由子区域划分的某些边和点围成）。所谓一个子区域划分的复杂度，就是构成该子区域划分的顶点、边和面的总数。

若一个顶点是某条边的端点，就说这个顶点与这条边是关联的（incident）。一张面与其边界上的每条边、每个顶点也是关联的。

这个数据结构要能完成以下操作：
- 围绕指定的某张面，沿其边界遍历（traverse）一周；
- 在指定一条公共边之后，通过与其相邻于一侧的面，找到另一侧的那张面；
- 在给定一个顶点之后，（依次）枚举出与之关联的所有边。

双向链接边表中会存储附加信息或者说属性信息（attribute information），用来扩展图的含义。这种数据结构中，一条边被当作两条边用，像劈竹子一样劈开，得到的叫做半边（half edge），两条半边方向相反，互为孪生兄弟（twin），但其左侧都是与它所关联的面。半边的起点（origin）与终点（destination）互相颠倒重合。

双向链接边表由三组记录构成：一组对应于顶点，一组对应于面，还有一组对应于边。举例以及三张表的结构如下：

<img src="doubly-connected_edge_list.webp" height="250px" />

| Vertex | Coordinates |  IncidentEdge   |
| :----: | :---------: | :-------------: |
| $v_1$  |   $(0,4)$   | $\vec{e}_{1,1}$ |
| $v_2$  |   $(2,4)$   | $\vec{e}_{4,2}$ |
| $v_3$  |   $(2,2)$   | $\vec{e}_{2,1}$ |
| $v_4$  |   $(1,1)$   | $\vec{e}_{2,2}$ |

| Face  | OuterComponent  | InnerComponents |
| :---: | :-------------: | :-------------: |
| $f_1$ |      $nil$      | $\vec{e}_{1,1}$ |
| $f_2$ | $\vec{e}_{4,1}$ |      $nil$      |

|    Half-edge    | Origin |      Twin       | IncidentFace |      Next       |      Prev       |
| :-------------: | :----: | :-------------: | :----------: | :-------------: | :-------------: |
| $\vec{e}_{1,1}$ | $v_1$  | $\vec{e}_{1,2}$ |    $f_1$     | $\vec{e}_{4,2}$ | $\vec{e}_{3,1}$ |
| $\vec{e}_{1,2}$ | $v_2$  | $\vec{e}_{1,1}$ |    $f_2$     | $\vec{e}_{3,2}$ | $\vec{e}_{4,1}$ |
| $\vec{e}_{2,1}$ | $v_3$  | $\vec{e}_{2,2}$ |    $f_1$     | $\vec{e}_{2,2}$ | $\vec{e}_{4,2}$ |
| $\vec{e}_{2,2}$ | $v_4$  | $\vec{e}_{2,1}$ |    $f_1$     | $\vec{e}_{3,1}$ | $\vec{e}_{2,1}$ |
| $\vec{e}_{3,1}$ | $v_3$  | $\vec{e}_{3,2}$ |    $f_1$     | $\vec{e}_{1,1}$ | $\vec{e}_{2,2}$ |
| $\vec{e}_{3,2}$ | $v_1$  | $\vec{e}_{3,1}$ |    $f_2$     | $\vec{e}_{4,1}$ | $\vec{e}_{1,2}$ |
| $\vec{e}_{4,1}$ | $v_3$  | $\vec{e}_{4,2}$ |    $f_2$     | $\vec{e}_{1,2}$ | $\vec{e}_{3,2}$ |
| $\vec{e}_{4,2}$ | $v_2$  | $\vec{e}_{4,1}$ |    $f_1$     | $\vec{e}_{2,1}$ | $\vec{e}_{1,1}$ |

在实际的问题中，需要定制化地增删记录内容。有些实现中，可能会要求子区域划分的顶点和边所对应的图必须是连通的，为此，需要引入一些虚边（dummy edge）。

### 计算子区域划分的叠合

给定两个子区域划分$S_1$和$S_2$，其叠合记作$O(S_1, S_2)$。

叠合算法首先将$S_1$和$S_2$所对应的两个双向链接边表复制到一个新的双向链接边表中，通过计算两个边网络之间的交点，并适当地将两个双向链接边表中的相关部分链接起来，最终把这个新的双向链接边表转化为对应于$O(S_1, S_2)$的一个合法的双向链接边表。
使用扫描线算法，在遇到一个事件点时，如果涉及到的边分别来自不同的子区域划分，则对新的双向链接边表做局部调整，保证扫描线扫过的区域已经被调整好。由于调整操作的复杂度不会超过线段求交算法的复杂度，所以可以在$O(nlogn + klogn)$时间内计算出$O(S_1, S_2)$所对应双向链接边表中所有顶点记录和半边记录，其中$n$为$S_1$和$S_2$的总体复杂度，而$k$为二者叠合结果的复杂度。
对于面，需要更复杂的操作。大致思路是构造一个图$G$，图的每一个节点对应一个环。利用这个图的节点，可以为每一连通子块生成一张面。而标记这张面属于原先的哪个子区域划分，则是看其顶点位于原子区域划分的哪个面内。

判断一个环是面的边界还是空洞的边界的方法是：找到环中最左端的顶点$v$（若有多个则选最低者），看与之相关联的两条边朝这张面内部所张的角度，小于$180°$则是外边界；否则就是空洞的边界。

{% note warning flat %}
TODO: 面的设置
{% endnote %}

> 定理 2.6
> 给定任意两个平面子区域划分$S_1$和$S_2$，其复杂度分别为$n_1$和$n_2$，令$n = n_1 + n_2$。则可以在$O(nlogn + klogn)$时间内计算出$S_1$和$S_2$的叠合，其中$k$为叠合结果的复杂度。

### 布尔运算

<img src="boolean_operation.webp" height="300px" />

地图叠合算法是一个强有力的工具，在众多不同的应用中它都可以大显身手。其中特别有用的一点，就是可以用以实现两个多边形$P_1$和$P_2$的布尔运算（boolean operation）——并（union）、交（intersection）和差（difference）。

> 推论 2.7
> 任意给定两个多边形$P_1$和$P_2$，设其顶点数分别为$n_1$、$n_2$，令$n := n_1 + n_2$。则可以在$O(nlogn + klogn)$时间内，计算出$P_1 ∩ P_2$、$P_1 ∪ P_2$或$P_1 \backslash P_2$，其中$k$为最终输出的复杂度。

## 多边形三角剖分：画廊看守

艺术画廊问题（art gallery problem）

### 看守与三角形剖分

对于多边形内部的任何一个点，只要联接于它与某台摄像机之间的开线段完全落在多边形的内部，它就能被这台摄像机监视到。“计算出特定多边形所需摄像机的最小数目”这一问题，是 NP-hard 问题。

通过极大的一组互不相交的对角线（diagonal），可将一个多边形分解为多个三角形——称作该多边形的三角剖分（trangulation）。
三角形剖分的例子：{% inlineImg trangulation.webp 100px %}

> 定理 3.1
> 任何简单多边形都存在（至少）一个三角形剖分；若其顶点数目为$n$，则它的每个三角形剖分都恰好包含$n - 2$个三角形。

由于顶点可能与多个三角形关联，所以把摄像机安排在顶点上。使用“对经过三角形剖分后的多边形的 3-染色（3-coloring）”来对多边形顶点进行染色。每个三角形三个顶点的颜色各异，相同颜色不会出现在一个三角形的一条边上。选用数量最少的那个颜色的点用来安排摄像机，则所需要的摄像机数目不会超过$⌊{n \over 3}⌋$。

一种获得 3-染色方案的办法是构建它的“对偶图”，其中，每个三角形作为图的顶点，若两个三角形共用一条对角线，则在图里面设置一条弧。由于对角线会把原多边形一分为二，所以对偶图是一棵树。从树的任意顶点开始遍历这棵树，第一个节点染上三种不同颜色，往后每到一个新顶点，由于这个顶点和上一个顶点有公共的边，而公共的边已经被染色完成，所以只需染一种颜色。

<img src="3_coloring.webp" height="150px" />

至此已经给出了艺术画廊问题的一个上届（upper bound）。

> 定理 3.2
> 包含$n$个顶点的任何简单多边形，只需（放置在适当位置的）$⌊{n \over 3}⌋$台摄像机就能保证：其中任何一点都可见于至少一台摄像机。有的时候，的确需要这样多台摄像机。

> 定理 3.3
> 任给一个包含$n$个顶点的简单多边形$P$。总可以在$O(nlogn)$时间内，在$P$中确定$⌊{n \over 3}⌋$台摄像机的位置，使得$P$中的任何一点都可见于其中的至少一台摄像机。

### 多边形的单调块划分

利用定理 3.1 的证明方式进行三角形剖分需要平方级的时间复杂度。而对凸多边形（convex polygon）的三角形剖分可以在线性时间内完成，可是将多边形划分为多个凸块的难度与对它做三角形剖分是一样的。因此我们将思路转变为把多边形划分为“单调块”（monotone piece）。

如果对任何一条垂直于$l$的直线$l'$，$l'$与该多边形的交都是连通的，则称作简单多边形“关于某条直线$l$单调”（monotone with respect to a line $l$）。连通的意思就是$l'$与多边形的交或者是一条线段，或者是一个点，也可能是一个空集。
更直观的理解是垂直于$l$的直线$l'$，只会把多边形分割为两个或者一个，不会更多。
如果一个多边形关于$y$坐标轴单调，则称它是$y$-单调的（$y$-monotone），这个多边形被称作$y$-单调多边形（$y$ monotone polygon）。它的一个特征是在沿着多边形的左（右）边界，从最高顶点走向最低顶点的过程中，我们是周都是朝下方（或者水平）运动，而绝不会向上。

把多边形的顶点分为五类，其中有四种拐点：起始顶点、分裂顶点、终止顶点以及汇合顶点。另一种是普通顶点。

<img src="vertex_type.webp" height="250px" />

- 起始顶点（start vertex）：与它相邻的两个顶点的高度都比它**低**，而且在该点处的内角**小于**$\pi$；
- 分裂顶点（split vertex）：与它相邻的两个顶点的高度都比它**低**，而且在该点处的内角**大于**$\pi$；
- 终止顶点（end vertex）：与它相邻的两个顶点的高度都比它**高**，而且在该点处的内角**小于**$\pi$；
- 汇合顶点（merge vertex）：与它相邻的两个顶点的高度都比它**高**，而且在该点处的内角**大于**$\pi$；
- 普通顶点（regular vertex）：除上述顶点外的所有顶点。

有了这些定义，就可以利用平面扫描算法来对多边形进行单调块划分。

> 引理 3.4
> 一个多边形若既不包含分裂顶点，也不含汇合顶点，则必然是$y$-单调的。

如上图，先将顶点与边的对应关系确定好，顶点逆时针排列为$v_1,v_2,...,v_n$，边$e_i=\overline{v_i v_{i+1}},1 \le i \lt n$；另外，$e_n = \overline{v_n v_1}$。
使用一条扫面线从上往下扫描，所有顶点被放到优先队列中，优先级的设置是顶点坐标$y\uparrow$，其次是坐标$x\downarrow$。（因为过程中不会产生新的事件点，所以使用其他排序算法先做排序也是可以的）
需要引入一个“助手”的概念：当扫描线遇到某个分裂顶点$v_i$时，从扫描线的状态结构中可以得到与$v_i$相邻的左、右两条边，令它们分别为$e_j$、$e_k$，那么介于两条边之间的那些位于$v_i$上方的顶点中，找到最低的那个，称作“$e_j的助手$（helper of $e_j$）”，记作 helper($e_j$)。正式的定义是“在位于扫描线上方、通过一条完全落在$P$内部的水平线段与$e_j$相联的那些顶点中，高度最低的那个顶点”。
那么消除分裂顶点的办法就是分别将它们与各自左侧那条相邻边的助手相联。
而对于汇合顶点$v_i$，扫描线到达它时，它就会成为它左侧那条边$e_j$的助手，当$e_j$的助手需要被替换时，判断其旧助手是否为汇合顶点，如果是，就在新、老助手之间引入一条对角线。若$e_j$的助手一直是$v_i$，直到扫描完成也没有改变，则将这个助手与$e_j$的下端点联接起来。

> 定理 3.6
> 使用$O(n)$的存储空间，可以在$O(nlogn)$时间内将包含$n$个顶点的任何简单多边形分解为多个$y$-单调的子块。

### 单调多边形的三角剖分

使用贪婪算法（greedy algorithm），在线性时间内，完成对单调多边形的三角剖分。
思路是从上往下遍历顶点，使用一个栈用来存储那些已经遍历过，但任可以产生更多对角线的顶点。
当遍历到一个顶点$u_j$时，判断其是在栈顶顶点的同一侧还是对面的一侧。对于对面侧的顶点，将其与栈内（除栈低元素）外的每一个顶点联对角线，并将$u_j$和$u_{j-1}$压入栈中；对于同一侧的顶点，依次检查它与栈顶元素的联线是否完全落在$P$的内部，若是则联线，弹出栈顶，最后将不能联线的两个顶点压入栈中。

> 定理 3.7
> 由$n$个顶点组成的任一严格$y$-单调多边形，都可以在线性时间内被三角剖分。

> 定理 3.8
> 使用$O(n)$的存储空间，可以在$O(nlogn)$时间内对由$n$个顶点组成的任一简单多边形进行三角剖分。

> 定理 3.9
> 使用$O(n)$存储空间，可以在$O(nlogn)$时间内对包含$n$个顶点的任一平面子区域划分进行三角剖分。


