---
title: 运筹学 - AHP层次分析法
date: 2023-07-18 19:37:06
updated: 2023-07-18 19:37:06
cover: supplier_problem.svg
tags:
    - 运筹学
    - AHP
categories:
    - 算法研究
---

> 层次分析法（The analytic hierarchy process）简称AHP，在20世纪70年代中期由美国运筹学家托马斯·塞蒂（T.L.saaty）正式提出。它是一种定性和定量相结合的、系统化、层次化的分析方法。由于它在处理复杂的决策问题上的实用性和有效性，很快在世界范围得到重视。它的应用已遍及经济计划和管理、能源政策和分配、行为科学、军事指挥、运输、农业、教育、人才、医疗和环境等领域。——层次分析法 - MBA智库百科

对于一个复杂的系统来说，直接对比每一套方案的优劣是一件很困难的事情。定性尚且困难，更不用说定量确定“方案一比方案二优秀百分之多少”这样的命题了。
这种场景下层次分析法就能很好派上用场，它的原理是将对于方案的评价分层分解为不同的指标，再利用经验或者求助专家对各个指标进行评分，最终通过计算可以得出不同方案的权重，利用该权重就能对方案有定量的比较了。

疑问有很多，我们带着以下几个主要的问题来学习AHP：
- “分层分解为不同的指标”是怎么回事？
- “对各个指标进行评分”，一旦指标数量过多，指标与指标之间如何定夺其重要性？是否会导致结果过于主观？
- “通过计算得到权重”，如何操作？是什么原理？

阅读完毕这篇文章，相信这些问题就能迎刃而解了。

## 建立层次结构模型

考虑选用供应商的场景，不同供应商有不同的优势，如果只关注供应商的供货价格而不考虑供应商的供货稳定性，可能导致实际生产过程中出现供货风险，从而不能及时交付产品。

### 建模举例

一种可能的层次结构模型如下：

{% plantuml %}
@startuml
left to right direction

skinparam rectangle<<behavior>> {
	roundCorner 25
}
sprite $bProcess jar:archimate/business-process
sprite $aService jar:archimate/application-service
sprite $aComponent jar:archimate/application-component
sprite $aInterface jar:archimate/application-interface

rectangle "供应商选择" as choose <<$bProcess>><<behavior>>

rectangle "成本 s1" as s1 <<$aService>><<behavior>>
rectangle "能力 s2" as s2 <<$aService>><<behavior>>
rectangle "服务 s3" as s3 <<$aService>><<behavior>>
rectangle "仓储 s4" as s4 <<$aService>><<behavior>>
rectangle "采购 s5" as s5 <<$aService>><<behavior>>

rectangle "产品价格 s11" as s11 <<$aComponent>><<behavior>>
rectangle "运输费用 s12" as s12 <<$aComponent>><<behavior>>

rectangle "项目管理能力 s21" as s21 <<$aComponent>><<behavior>>
rectangle "在大众中的口碑 s22" as s22 <<$aComponent>><<behavior>>
rectangle "在甲方中的口碑 s23" as s23 <<$aComponent>><<behavior>>
rectangle "工作人员的水平和能力 s24" as s24 <<$aComponent>><<behavior>>

rectangle "售后处理速度 s31" as s31 <<$aComponent>><<behavior>>
rectangle "售后处理方案 s32" as s32 <<$aComponent>><<behavior>>

rectangle "现货数量 s41" as s41 <<$aComponent>><<behavior>>
rectangle "交付及时性 s42" as s42 <<$aComponent>><<behavior>>
rectangle "供货稳定性 s43" as s43 <<$aComponent>><<behavior>>

rectangle "对接多少采购方 s51" as s51 <<$aComponent>><<behavior>>
rectangle "在采购方中的优先级 s52" as s52 <<$aComponent>><<behavior>>
rectangle "其他采购方采购数量 s53" as s53 <<$aComponent>><<behavior>>

rectangle "供应商 1" as g1 <<$aInterface>><<behavior>>
rectangle "供应商 2" as g2 <<$aInterface>><<behavior>>
rectangle "供应商 3" as g3 <<$aInterface>><<behavior>>

choose -- s1
choose -- s2
choose -- s3
choose -- s4
choose -- s5

s1 -- s11
s1 -- s12

s2 -- s21
s2 -- s22
s2 -- s23
s2 -- s24

s3 -- s31
s3 -- s32

s4 -- s41
s4 -- s42
s4 -- s43

s5 -- s51
s5 -- s52
s5 -- s53

s11 -- g1
s12 -- g1
s21 -- g1
s22 -- g1
s23 -- g1
s24 -- g1
s31 -- g1
s32 -- g1
s41 -- g1
s42 -- g1
s43 -- g1
s51 -- g1
s52 -- g1
s53 -- g1

s11 -- g2
s12 -- g2
s21 -- g2
s22 -- g2
s23 -- g2
s24 -- g2
s31 -- g2
s32 -- g2
s41 -- g2
s42 -- g2
s43 -- g2
s51 -- g2
s52 -- g2
s53 -- g2

s11 -- g3
s12 -- g3
s21 -- g3
s22 -- g3
s23 -- g3
s24 -- g3
s31 -- g3
s32 -- g3
s41 -- g3
s42 -- g3
s43 -- g3
s51 -- g3
s52 -- g3
s53 -- g3

@enduml
{% endplantuml %}

### 模型解释

一般的层次结构模型应当包含三层：
- 最高层（解决问题的目的）
- 中间层（策略层、约束层、准则层）
- 最低层（用于解决问题的各种措施、方案等）

最高层是我们的目标，即“供应商选择”。

对于每个供应商，我们考察其五个方面（准则层）：
1. 成本：即我作为采购方需要付给供应商的金额
2. 能力：即乙方作为供应商的整体实力
3. 服务：即供应商的服务水平
4. 仓储：指示供应商供货能力
5. 采购：考虑到可能有多个采购方同时对接一个供应商，需考虑其他采购方对我们造成的供货风险

这个场景中，准则层也还比较抽象，如果直接对供应商进行这5个方面的评分则不够直观。这种情况下我们就可以继续往下细分，将准则层的每个因素分解为更下一层的指标，我们称之为“指标层”。例如，我们将“能力”细分为以下指标：
1. 项目管理能力
2. 在大众中的口碑
3. 在甲方中的口碑
4. 工作人员水平和能力

至此每个指标已经变得足够简单，容易依照它们对供应商进行两两比较，分层则结束。

最底层是方案层，对于我们这个例子来说就是不同的供应商，每个供应商作为一个方案。

## 构造对比较矩阵

由上一节举的例子可以感受出，对于供应商的选择，我们最底层需要考虑14个不同因素。我们需要逐层计算出它们对上一层的贡献，最终汇总到对供应商选择的贡献，为此我们需要对每一个参数进行“评分”。
可问题是我们应该如何确定评分标准？这么多因素一起考虑，需要对每一个因素打出分数的“绝对值”，这无疑是非常困难的。

AHP中，我们使用比较矩阵，每次只考虑两个因素，两两比较时我们只需要考虑其相对重要性就好了，大大降低了评分的难度。
例如，对于“能力 s2”指标的四个因素，我们构造如下的比较矩阵：

|s2|项目管理能力 t21|在大众中的口碑 t22|在甲方中的口碑 t23|工作人员的水平和能力 t24|
|:-:|:-:|:-:|:-:|:-:|
|项目管理能力 t21|1||||
|在大众中的口碑 t22||1|||
|在甲方中的口碑 t23|||1||
|工作人员的水平和能力 t24||||1|

由其中对角线已经填好的“1”我们可以窥见这个表格应该怎么填：最左上角的“1”表示“项目管理能力 t21 和 项目管理能力 t21 具有同样的重要性”，这是显而易见的，因为两个相同的因素，没有优劣之分。对于其他格子，我们可以参照下表进行填写：

|标度|含义|
|:-:|:-:|
|1|表示两个元素相比，具有同样的重要性|
|3|表示两个元素相比，前者比后者稍重要|
|5|表示两个元素相比，前者比后者明显重要|
|7|表示两个元素相比，前者比后者极其重要|
|9|表示两个元素相比，前者比后者强烈重要|
|2,4,6,8|表示上述相邻判断的中间值|
|1~9的倒数|表示相应量因素交换次序比较的重要性|

对于其他位于中间层的指标，我们也需要建立其比较矩阵。同时，对于最高层，我们也需要建立其相对于中间层指标的比较矩阵：

|r|成本 s1|能力 s2|服务 s3|仓储 s4|采购 s5|
|:-:|:-:|:-:|:-:|:-:|:-:|
|成本 s1|1|||||
|能力 s2||1||||
|服务 s3|||1|||
|仓储 s4||||1||
|采购 s5|||||1|

我们来尝试填写上表：

|r|成本 s1|能力 s2|服务 s3|仓储 s4|采购 s5|
|:-:|:-:|:-:|:-:|:-:|:-:|
|成本 s1|1|`7`|6|6|7|
|能力 s2|`1/7`|1|2|1/3|1/3|
|服务 s3|1/6|1/2|1|1/3|1/3|
|仓储 s4|1/6|3|3|1|3|
|采购 s5|1/7|3|3|1/3|1|

可以看到表中标出来的`7`和`1/7`，它们关于对角线对称，所以值也是对称的，即“成本”对应于“能力”的重要程度为“成本极其重要”，那么“能力”对应于成本则是其倒数（excel中设置矩阵的左下元素为`=1/右上对应元素`，则填写时只需填写表格的一半）。

### 层次单排序

有了比较矩阵，我们就可以计算出每个因素对于上一层的贡献，即权重了。权重计算有两种方法：
- 方根法
- 和积法

和积法理解简单，但方根法更适合用公式来表示，我们这里选择方根法进行计算。有以下步骤：
- 按行元素求积，再求${1 \over n}$次幂，得到$w_i$，公式为：
$$
\bar{w_i} = \sqrt[m]{\prod_{j=1}^{m}a_{ij}}
$$
- 将$w_i$归一化，得到权值，也是后续需要使用的特征向量，公式为：
$$
w_i = {\bar{w_i} \over \sum_{j=1}^{m}\bar{w_j}}
$$

使用excel求解，两步的公式参考如下（注意修改参数为实际表格坐标）：
- `=POWER(PRODUCT(E18:I18),1/COUNT(E18:I18))`
- `=E25/SUM(E25:E29)`

求解得s1-5对应r的权重向量为：
|方根法计算权重|$\bar{w_i}$|$w_i$|
|:-:|:-:|:-:|
|成本 s1|4.459639117|0.590811854|
|能力 s2|0.501577318|0.066448835|
|服务 s3|0.392026341|0.05193555|
|仓储 s4|1.350960039|0.178974842|
|采购 s5|0.84412088|0.111828919|

显然，对于s1-s5这五个参数来说，**成本**是对于供应商选择最为重要的，其重要性达到了%59；而**服务**是最为不重要的，只占到了%5。

## 作一致性检验

我们虽然已经利用层次单排序求得了s1-5对应于r的权重值，但能否进行层次单排序其实是没有确定的，也就是说这个权重是否可以使用是没有经过检验的。而一致性检验就是为了完成这个工作。

因为比较矩阵是人为填写的，有时候可能会出现不符合逻辑的情况，比如说`a`的重要性是`b`的2倍，而`b`的重要性是`c`的两倍，这时候按道理说`a`的重要性是`c`的8倍；用定性的例子说，`a`的重要性比`b`高，而`b`的重要性比`c`高，此时按理来说`a`应当比`c`重要。但如果填写错误，可能填成了`a`的重要性是`c`的2倍，甚至`a`还不如`c`重要的情况，这就出现了逻辑错误，这种错误在一致性检验过程中是可以被发现的。

一致阵拥有如下的性质：
- $a_{ij}={1 \over a_{ij}}, a_{ii} = 1(i,j=1,2,...,n)$；
- $A^T$也是一致阵；
- $A$的各行成比例，即$A$矩阵秩为1；
- $A$的最大特征根（值）为$\lambda=n$，其余的$n-1$个特征根均等于0；
- $A$的任一列（行）都是对应于特征根$n$的特征向量，$AW=nW$。

使用如下定理：
- $n$阶一致阵的唯一非零特征根为$n$；
- $n$阶互反阵$A(a_{ij}>0,a_{ij}={1 \over a_{ji}},a_{ii}=1)$最大特征根$\lambda>=n$，当且仅当$\lambda=n$时，$A$为一致矩阵。

可以推出，$\lambda$需要尽可能接近$n$，如果$\lambda$越大，则说明矩阵越不具有一致性。

为了衡量这个值，我们定义一个**一致性指标$CI$**：
$$
CI={\lambda-n \over n-1}
$$
这个值可以判断矩阵一致性，是因为：
- $CI=0$，代表$\lambda=n$，矩阵为一致阵，具有完全的一致性；
- $CI$接近0，代表$\lambda$接近$n$，矩阵一致性可以接受；
- $CI$大于一定阈值，说明一致性不过关。

使用excel求解公式举例：`=(S18-COUNT(L18:L22))/(COUNT(L18:L22)-1)`

公式中的$n$是已知值，但$\lambda$需要求解，其公式为：
$$
\lambda_{max}={1 \over n}\sum_{i=1}^{n}{(Aw)_i \over w_i}
$$

使用excel求解公式举例：
- $Aw$: `=SUM(L18:P18)`
- ${Aw \over w}$: `=Q18/F25`
- $\lambda_{max}$: `=SUM(R18:R22)/COUNT(L18:L22)`

但如果直接用$CI$来衡量矩阵一致性，不好确定阈值，于是引入了随机一致性指标$RI$，将我们的$CI$值与标准的$RI$值相比，则得到一个相对比率，对这个比率确定阈值是可行的事情。其计算方法为构造非常多的一致阵，计算其平均$CI$值。我们无需手动完成这个工作，查表即可。

|矩阵阶数 n|1|2|3|4|5|6|7|8|9|10|11|12|13|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|RI|0|0|0.58|0.9|1.12|1.24|1.32|1.41|1.45|1.49|1.51|1.54|1.56|

一致性比率$CR$：
$$
CR={CI \over RI}
$$

一般，当一致性比率$CR<0.1$时，认为矩阵的一致性是可以接受的，一致性检验通过。

利用上述方法，我们求得s1-5对应r的各项数据如下：
- $\lambda_{max}=5.404934181$
- $CI=0.101233545$
- $RI=1.12$
- $CR=0.090387094$

$CR<0.1$，一致性检验通过，则上一节计算出的权重向量$w_i$是可用的。

### 其他矩阵

现在我们求得了s1-5对应于r的权重向量$w_i=(0.590811854,0.066448835,0.05193555,0.178974842,0.111828919)^T$并通过了一致性检验，使用同样的方法，将t11-t12对s1、t21-t24对s2、t31-32对s3、t41-43对s4还有t51-53对s5的权重向量都求出来，建模部分就已经完成了，此时我们就可以使用层次总排序开始逐层往上确定方案选择了。

## 层次总排序及决策
