---
title: 《计算几何——算法与应用（第三版）》学习笔记2 - 空间索引
date: 2023-10-24 15:11:38
updated: 2023-10-24 15:11:38
cover: cover.webp
katex: true
tags:
    - 计算几何
categories:
    - 学习笔记
---

{% note info flat %}
**系列文章**
{% post_link computational-geometry-algorithms-and-applications %}
-> {% post_link computational-geometry-algorithms-and-applications-1 %}
**番外篇**
{% post_link computational-geometry-libraries %}
{% post_link try-boost-geometry %}
{% endnote %}

## 正交区域查找：数据库查询

将数据库中的每条记录对应到多维空间中的一个点，这样就可以将本来针对记录的查询变成针对点的查询。例如下图，把“yyyymmdd”格式的日期作为 x 坐标，把“月收入”作为 z 坐标，把“家庭成员数量”作为 y 坐标，图中的立方体就可以作为“查询出生于 1950 年至 1955 年之间、月收入在 $3000 至 $4000 之间并且家庭成员有 2 到 4 人的所有员工”的几何化表示。

<img src="space_query.webp" height="200px"/>

有了这种表示，接下来要解决的问题是如何找到落在这个立方体中的点。在计算几何中，这类查询被称为矩形区域查询（rectangular range query），或者正交区域查找（orthogonal range query）。

### 一维区域查找

对于一维的区域查找问题（range searching problem），使用平衡二分查找树来解决。
对区域的左边和右边数值分别做一次查找，这两次查找结果之间的所有叶子结点则是区域查找的结果。

一个优化手段是只有某个节点将查询区域分隔开，才需要对两棵子树分别搜索。

由于查询时间跟需要输出的点的数量有关，所以算法是输出敏感的（output-sensitive）。
| 空间复杂度 | 构造时间复杂度 | 查询时间复杂度 |
| :--------: | :------------: | :------------: |
|   $O(n)$   |   $O(nlogn)$   | $O(logn + k)$  |

> 定理 5.2
> 给定由一维空间中任意 n 个点构成的集合 P。可以使用$O(n)$空间，在$O(nlogn)$时间内构造一棵平衡二分查找树以存储 P。这样，可以在$O(k+logn)$时间内查找出任何区间内的所有点（其中，k 是实际被查找出来的点数）。

### kd-树

（k-dimensional tree）

每次二维矩形区域查找，都可以分解为两次一维子查找——其中一次沿 x 方向进行，另一次沿 y 方向进行。

将二分查找树的思路扩充到二维，对于深度为偶数的节点，使用垂线进行划分；对于深度为奇数的节点，使用水平线进行划分。每次划分分别存储到当前节点的左、右孩子节点中。2d-树（2维 kd-树，2-dimensional kd-tree）举例如下：

<img src="kd-tree.webp" height="250px"/>

| 空间复杂度 | 构造时间复杂度 | 查询时间复杂度  |
| :--------: | :------------: | :-------------: |
|   $O(n)$   |   $O(nlogn)$   | $O(\sqrt{n}+k)$ |

> 引理 5.3
> 给定由任意 n 个点组成的一个集合，其对应的 kd-树占用$O(n)$空间，并可以在$O(nlogn)$时间内构造出来。

> 引理 5.4
> 如果待查询区域为与坐标轴平行的区域，那么对于存储了任意 n 个点的一棵 kd-树，每次查询都可以在$O(\sqrt{n}+k)$时间内完成，其中 k 为实际被报告出来的点数。

> 定理 5.5
> 给定由平面上任意 n 个点构成的集合 P，其对应的 kd-树将占用$O(n)$空间，并且可以在$O(nlogn)$时间内构造出来。使用这棵 kd-树，每次矩形区域查找锁需的时间将不会超过$O(\sqrt{n}+k)$，其中 k 为实际被报告出来的点数。

如果要扩展到更高的维度，只需按照维度顺序分割点集即可。
| 空间复杂度 | 构造时间复杂度 |      查询时间复杂度      |
| :--------: | :------------: | :----------------------: |
|   $O(n)$   |   $O(nlogn)$   | $O(n^{1-{1 \over d}}+k)$ |

### 区域树

（range tree）

| 空间复杂度 | 构造时间复杂度 | 查询时间复杂度 |
| :--------: | :------------: | :------------: |
| $O(nlogn)$ |   $O(nlogn)$   | $O(log^2n+k)$  |

其核心思想是用空间换时间，除了建立一棵主树（main tree）之外，还建立一系列小一些的树。主树的每个内部节点或者叶子节点，都存储有一个指针，指向一棵平衡二分查找树，我们称这颗小的二分查找树为节点的联合结构（associated structure）。

- 主树：将 P 中各点按照 x 坐标组织成平衡二分查找树。
- 联合结构：主树中，获得该节点对应的子树，将子树的叶子节点对应的 P 的子集 P' 再组织成按照 y 坐标为依据的二分查找树。

这种情况下，查询特定矩形区域的点，只需要使用一次一维二分查找，找出 x 坐标落在该矩形区域的 P 的子集，这个子集会对应一系列的联合结构，对这些联合结构再做一维的二分查找，就可以筛选出查询结果。

拥有联合结构的数据结构称为多层次数据结构（multi-level data structure）。主树被称为第一层的树（first-level tree），每一联合结构都被称为第二层的树（second-level tree）。

> 引理 5.6
> 给定由平面上任意 n 个点构成的点集，其对应的区域树占用$O(nlogn)$的存储空间。

> 引理 5.7
> 若采用区域树来存储（平面上的）任意 n 个点，则与坐标方向平行的每一次矩形区域查询，只需要$O(log^2n+k)$时间。这里的 k 为实际报出来的点数。

> 定理 5.8
> 给定由平面上任意 n 个点构成的集合 P。对应于 P 的一棵区域树占用$O(nlogn)$的存储空间，并且可以在$O(nlogn)$时间内构造出来。对这棵区域树进行查找，可以在$O(log^2n+k)$时间内，从 P 中报告出落在任一矩形待查区域之内的所有点，其中 k 为实际被报告出来的点数。

如果使用**分散层叠**（fractional cascading）技术，查询时间还可以进一步改进至$O(logn+k)$。

### 高维区域树

要创建一棵 d 维的区域树，假设其中点的坐标为$(x_1, x_2, x_3, ..., x_d)$，只需按维度一级一级创建联合结构即可。
具体来说就是，将所有点按照$x_1$组织成一棵平衡二分查找树，对于其中每个节点，我们取出它对应的子树的叶子节点的那个子集，继续按照$x_2$组织成一棵平衡二分查找树，以此类推，直到使用上最后一维的坐标$x_d$。

查找时，也是逐级进行搜索，首先使用第一层的树搜索出$x_1$落在搜索范围内的点点子集，然后使用第二维的树搜索$x_2$符合要求的点。直到搜索完一维的树，就筛选出所有 d 个维度均落在搜索区域中的点。

> 定理 5.9
> 给定由 d 维空间中任意 n 个点构成的集合 P，d≥2。对应于 P 的一棵区域树占用$O(nlog^{d-1}n)$的存储空间，并且可以在$O(nlog^{d-1}n)$时间内构造出来。对这棵区域树进行查找，可以在$O(log^dn+k)$时间内，从 P 中报告出落在给定（超）矩形待查区域之内的所有点，其中 k 为实际被报告出来的点数。

### 一般性点集

满足来自某个全序域（totally ordered universe）的点集，可以对其中任意两个坐标进行比较，并可以计算中值。
方法是将原县表示为实数的坐标，替换为来自所谓合成数空间（composite number space）的元素。通俗来说，就是比较时考虑全部维度的数据，如果第一维相同，就比较第二维，以此类推，直到分出大小（例如`return p1.x == p2.x ? p1.y > p2.y : p1.x > p2.x;`）。按照字典序（lexicographical order），我们可以在合成数空间中定义一个全序（total order）。

由以上方法，前文所述的区域查找就可以支持点的某些坐标相同的情况了。

### $^*$分散层叠

{% note warning flat %}
TODO:思路
{% endnote %}

> 定理 5.11
> 在 d(≥2) 维空间中，给定由任意 n 个点构成的集合 P。总可以在$O(nlog^{d-1}n)$时间内，构造出一棵与 P 对应的层次化区域树，其占用的存储空间为$O(nlog^{d-1}n)$。借助这棵区域树，可以在$O(log^{d-1}n+k)$时间内，报告出 P 中落在某矩形待查区域之内的所有点，其中 k 为实际被报告出来的点数。

### 注释及评论

空间索引发展历程：

- 首先提出的是四叉树（quadtree），但其在最坏情况下性能相当差。
- 1975 年 Bentley 提出了 kd-树，对四叉树进行改进。
- 之后提出了区域树。
- 再之后提出了分散层叠技术。
- Chazelle 提出了修改后的层次化区域树，是解决二维区域查找问题最有效的数据结构，空间复杂度为$O(n(logn/loglogn)^{d-1})$。
- 如果查找区域某侧无界，则使用优先查找树（priority search tree），空间复杂度是线性的，时间复杂度为$O(logn)$。
- ……


