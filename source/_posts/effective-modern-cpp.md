---
title: 《Effective Modern C++》学习笔记
date: 2023-07-25 09:15:16
updated: 2023-07-25 09:15:16
cover: cover.jpg
tags:
    - C++
categories:
    - 学习笔记
---

> 现代 C++（即 C++11/C++14）远不止是修修补补。考虑所有的功能，这简直是一门语言的脱胎换骨。

## 绪论

一个对象是右值意味着能够对其实施移动语义，而左值则一般不然。
有一种甄别表达式是否左值的实用方法富有启发性，那就是检查能否取得该表达式的地址。如果可以取得，那么该表达式基本上可以断定是左值。如果不可以，则其通常是右值。

## 第一章 - 型别推导

### 条款 1：理解模板型别推导

- 在模板型别推导过程中，具有引用型别的实参会被当成非引用型别来处理。换言之，其引用型会被忽略。
- 对万能引用形参进行推导时，左值实参会进行特殊处理。
- 对按值传递的形参进行推导时，若实惨型别中带有`const`或`volatile`饰词，则它们还是虎背当作不带`const`或`volatile`饰词的型别来处理。
- 在模板型别推导过程中，数组或函数型别的实参会退化成对应的指针，除非它们被用来初始化引用。

### 条款 2：理解 auto 型别推导

```C++
    auto x3 = { 27 };
    auto x4{ 27 };
```
以上两条语句，auto 推导出来的型别为`std::initializer_list<int>`。
但是，如果向对应的模板传入一个同样的初始化表达式，型别推导就会失败，代码将不能通过编译：
```C++
template<typename T>
void f(T param);

f({ 27 });  // 错误！无法推导 T 的型别
```

- 在一般情况下，auto 型别推导和模板型别推导时一模一样的，但是 auto 型别推导会假定用大括号括起来的初始化表达式代表一个`std::initializer_list`，但模板型别推导却不会。
- 在函数返回值或 lambda 式的形参中使用 auto，意思是使用模板型别推导而非 auto 型别推导。

### 条款 3：理解 decltype

- 绝大多数情况下，decltype 会得出变量或表达式的型别尔不做任何修改。
- 对于型别为 T 的左值表达式，除非该表达式仅有一个名字，decltype 总是得出型别 T&。
- C++14 支持 decltype(auto)，和 auto 一样，它会从其初始化表达式出发来推导型别，但是它的型别推导使用的是 decltype 的规则。

### 条款 4：掌握查看型别推导结果的方法

- 利用 IDE 编辑器、编译器错误消息和 Boost.TypeIndex 库常常能够查看到推导而得的型别。
- 有些工具产生的结果可能会无用，或者不准确。所以，理解 C++ 型别推导规则是必要的。

## 第二章 - auto

### 条款 5：优先选用 auto，而非显式型别声明

- auto 变量必须初始化，基本上对会导致兼容性和效率问题的型别不匹配现象免疫，还可以简化重构流程，通常也比显式指定型别要少打一些字。
- auto 型别打变量都有着条款 2 和条款 6 中所描述的毛病

### 条款 6：当 auto 推导的型别不符合要求时，使用带显式型别的初始化物习惯用法

`std::vector<bool>`的`operator[]`返回的是个`std::vector<bool>::reference`型别的对象。这是因为`std::vector<bool>`做过特化，用了一种压缩形式表示其持有的`bool`元素，每个`bool`元素用一个比特来表示。

- “隐形”的代理型别可以导致 auto 根据初始化表达式推导出“错误的”型别。
- 带显式型别的初始化物习惯用法强制 auto 推导出你想要的型别。

## 第三章 - 转向现代 C++

### 条款 7：在创建对象时注意区分`()`和`{}`


